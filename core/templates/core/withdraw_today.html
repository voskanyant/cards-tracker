{% extends "core/base.html" %}
{% load formatting %}
{% block content %}

<section class="section-card">
    <div style="display:flex; flex-direction:column; gap:12px;">
      <h2 style="margin:0;">Withdraw Today</h2>
      <div style="display:flex; flex-wrap:wrap; gap:12px; width:100%;">
        <label style="display:flex; flex-direction:column; min-width:160px;">
          <span>Work date</span>
          <div class="date-field">
            <input id="workdate" type="text" placeholder="dd/mm/yyyy" value="{{ day_display }}" autocomplete="off" inputmode="numeric" class="date-input js-date-input">
            <button type="button" class="calendar-toggle" aria-label="Open calendar">&#128197;</button>
          </div>
        </label>
        <label style="display:flex; flex-direction:column; min-width:220px;">
          <span>Bank filter</span>
          <div class="combo-wrapper">
            <input type="hidden" id="bank-filter" value="{{ selected_bank }}">
            <input type="text" id="bank-input" class="combo-input" data-combo-list="withdraw-bank-options" placeholder="Start typing bank..." value="{{ selected_bank }}" autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false">
            <div class="combo-dropdown"></div>
          </div>
        </label>
        <label style="display:flex; flex-direction:column; min-width:220px; flex:1;">
          <span>Search</span>
          <input type="text" id="withdraw-search" placeholder="Search card/bank/pin..." value="{{ query }}" autocomplete="off">
        </label>
        <label class="withdraw-per-page" style="display:flex; flex-direction:column; min-width:140px;">
          <span>Per page</span>
          <select id="withdraw-per-page">
            {% for option in per_page_choices %}
              <option value="{{ option }}" {% if option == per_page %}selected{% endif %}>{{ option }}</option>
            {% endfor %}
          </select>
        </label>
        <datalist id="withdraw-bank-options">
          {% for bank in banks %}
            <option data-id="{{ bank }}" value="{{ bank }}"></option>
          {% endfor %}
        </datalist>
      </div>
    </div>

	  {% csrf_token %}

  <div class="table-card table-scroll" style="margin-top:16px;">
	  <table class="withdraw-table">
		<thead>
		  <tr>
			<th class="col-card">Card</th>
			<th class="col-pin">PIN</th>
			<th class="num col-money">Due ₽</th>
			<th class="col-full">Full</th>
			<th class="num col-money-input">Taken ₽</th>
			<th class="num col-money-input">Fee ₽</th>
			<th class="num col-money">Left ₽</th>
			<th class="col-note">Note</th>
		  </tr>
		</thead>



		<tbody>
		  {% for r in page_obj %}
			<tr data-card-id="{{ r.card_id }}" data-should="{{ r.should_have|floatformat:'2' }}">
			  <td class="col-card">{{ r.card_label }}</td>
			  <td class="col-pin"><b>{{ r.pin }}</b></td>
			  <td class="num col-money"><b>{{ r.should_have|spaced_number }} ₽</b></td>

			  <td class="col-full">
				<input type="checkbox" class="full"
					   {% if r.withdrawal and r.withdrawal.fully_withdrawn %}checked{% endif %}>
			  </td>

			  <td class="num col-money-input">
				<div class="currency-input">
				  <span class="currency-prefix">₽</span>
				  <input type="text" inputmode="decimal" class="withdrawn" 
					 value="{% if r.withdrawal %}{{ r.withdrawal.withdrawn_rub|default:'' }}{% endif %}"
					 {% if r.withdrawal and r.withdrawal.fully_withdrawn %}disabled{% endif %}>
				</div>
			  </td>

			  <td class="num col-money-input">
				<div class="currency-input">
				  <span class="currency-prefix">₽</span>
				  <input type="text" inputmode="decimal" class="commission" 
					  value="{% if r.withdrawal %}{{ r.withdrawal.commission_rub|default:'' }}{% endif %}"
					  {% if r.withdrawal and r.withdrawal.fully_withdrawn %}disabled{% endif %}>
				</div>
			  </td>

			  <td class="num col-money"><b class="remaining-value">{{ r.remaining|spaced_number }} ₽</b></td>

			  <td class="col-note">
				<div class="note-cell {% if r.withdrawal and r.withdrawal.note %}has-note{% endif %}">
				  <button type="button" class="note-trigger" aria-label="{% if r.withdrawal and r.withdrawal.note %}Edit note{% else %}Add note{% endif %}">
					{% if r.withdrawal and r.withdrawal.note %}
					  <span class="note-icon" title="{{ r.withdrawal.note|escape }}">i</span>
					{% else %}
					  <span class="note-icon">+</span>
					{% endif %}
				  </button>
				  <input type="hidden" class="note note-input" value="{% if r.withdrawal %}{{ r.withdrawal.note|default:'' }}{% endif %}">
				</div>
			  </td>
			</tr>

		  {% empty %}
			<tr><td colspan="8">No cards to withdraw for this date.</td></tr>
		  {% endfor %}
		</tbody>
		<tfoot>
		  <tr>
			<td colspan="2"><b>Totals</b></td>
			<td class="num col-money"><b id="total-should">{{ totals.should|default:0|spaced_number }}</b> ₽</td>
			<td></td>
			<td class="num col-money"><b id="total-withdrawn">{{ totals.withdrawn|default:0|spaced_number }}</b> ₽</td>
			<td class="num col-money"><b id="total-commission">{{ totals.commission|default:0|spaced_number }}</b> ₽</td>
			<td class="num col-money"><b id="total-remaining">{{ totals.remaining|default:0|spaced_number }}</b> ₽</td>
			<td></td>
		  </tr>
		</tfoot>
	  </table>
  </div>

    <p style="margin-top:12px; color:var(--muted); font-size:0.9rem;">
      Tip: edit withdrawals inline and they autosave instantly.
    </p>
</section>

<div class="note-modal" id="note-modal">
  <div class="note-modal-content">
    <h3>Card Note</h3>
    <textarea id="note-modal-text" rows="5" placeholder="Type note..."></textarea>
    <div class="note-modal-actions">
      <button type="button" data-note-action="delete" class="danger">Delete</button>
      <div class="note-modal-actions-right">
        <button type="button" data-note-action="cancel">Cancel</button>
        <button type="button" data-note-action="save" class="primary">Save</button>
      </div>
    </div>
  </div>
</div>

  {% if page_obj.has_other_pages %}
    <div class="pagination" style="margin-top:16px; display:flex; gap:8px; flex-wrap:wrap; align-items:center;">
      {% if page_obj.has_previous %}
        <a href="?{% if day_display %}date={{ day_display|urlencode }}&{% endif %}{% if selected_bank %}bank={{ selected_bank|urlencode }}&{% endif %}{% if query %}q={{ query|urlencode }}&{% endif %}per_page={{ per_page }}&page={{ page_obj.previous_page_number }}">Prev</a>
      {% endif %}
      {% for num in page_items %}
        {% if num %}
          {% if num == page_obj.number %}
            <span style="padding:4px 8px; border-radius:8px; background:#e2e8f0; font-weight:600;">{{ num }}</span>
          {% else %}
            <a href="?{% if day_display %}date={{ day_display|urlencode }}&{% endif %}{% if selected_bank %}bank={{ selected_bank|urlencode }}&{% endif %}{% if query %}q={{ query|urlencode }}&{% endif %}per_page={{ per_page }}&page={{ num }}" style="padding:4px 8px;">{{ num }}</a>
          {% endif %}
        {% else %}
          <span style="padding:4px 6px; color:var(--muted);">...</span>
        {% endif %}
      {% endfor %}
      {% if page_obj.has_next %}
        <a href="?{% if day_display %}date={{ day_display|urlencode }}&{% endif %}{% if selected_bank %}bank={{ selected_bank|urlencode }}&{% endif %}{% if query %}q={{ query|urlencode }}&{% endif %}per_page={{ per_page }}&page={{ page_obj.next_page_number }}">Next</a>
      {% endif %}
    </div>
  {% endif %}

	<script>
	  // --- CSRF ---
	  function getCookie(name) {
		const value = `; ${document.cookie}`;
		const parts = value.split(`; ${name}=`);
		if (parts.length === 2) return parts.pop().split(";").shift();
	  }
	  const csrftoken = getCookie("csrftoken");

	  // --- Saving state ---
	  let inFlight = 0;
	  let pendingNavUrl = null;

	  function setSavingText() {
		let el = document.getElementById("saving-status");
		if (!el) {
		  el = document.createElement("div");
		  el.id = "saving-status";
		  el.style.margin = "8px 0";
		  el.style.fontSize = "12px";
		  document.body.querySelector("main")?.prepend(el);
		}
		el.textContent = inFlight > 0 ? "Saving..." : "";
	  }

	  function parseNumber(value) {
		if (typeof value === "number") {
		  return Number.isFinite(value) ? value : 0;
		}
		if (value === undefined || value === null) return 0;
		const normalized = String(value).replace(/\s+/g, "").replace(",", ".");
		const parsed = parseFloat(normalized);
		return Number.isFinite(parsed) ? parsed : 0;
	  }

	  function normalizeNumberString(value) {
		if (value === undefined || value === null) return "";
		const normalized = String(value).replace(/\s+/g, "").replace(",", ".");
		return normalized;
	  }

	  function formatNumber(value) {
		const rounded = Math.round((value + Number.EPSILON) * 100) / 100;
		let [intPart, fracPart] = rounded.toFixed(2).split(".");
		const sign = intPart.startsWith("-") ? "-" : "";
		intPart = intPart.replace("-", "");
		intPart = intPart.replace(/\B(?=(\d{3})+(?!\d))/g, " ");
		fracPart = fracPart.replace(/0+$/, "");
		const formattedInt = `${sign}${intPart || "0"}`;
		return fracPart ? `${formattedInt}.${fracPart}` : formattedInt;
	  }

	  function escapeHtml(value) {
		return String(value || "")
		  .replace(/&/g, "&amp;")
		  .replace(/</g, "&lt;")
		  .replace(/>/g, "&gt;")
		  .replace(/"/g, "&quot;")
		  .replace(/'/g, "&#039;");
	  }

	  function computeRowState(row) {
		const should = parseNumber(row.dataset.should);
		const fullEl = row.querySelector(".full");
		const withdrawnEl = row.querySelector(".withdrawn");
		const commissionEl = row.querySelector(".commission");

		const full = fullEl?.checked ?? false;
		if (withdrawnEl) {
		  withdrawnEl.disabled = full;
		}
		if (commissionEl) {
		  commissionEl.disabled = full;
		}
		const withdrawn = full ? should : parseNumber(withdrawnEl?.value);
		const commission = full ? 0 : parseNumber(commissionEl?.value);
		let remaining = should - withdrawn - commission;
		if (remaining < 0) remaining = 0;

		const remainingEl = row.querySelector(".remaining-value");
		if (remainingEl) {
		  remainingEl.textContent = `${formatNumber(remaining)} ₽`;
		}

		return { should, withdrawn, commission, remaining };
	  }

	  function refreshTotals() {
		const totals = { should: 0, withdrawn: 0, commission: 0, remaining: 0 };
		document.querySelectorAll("tr[data-card-id]").forEach(row => {
		  const state = computeRowState(row);
		  totals.should += state.should;
		  totals.withdrawn += state.withdrawn;
		  totals.commission += state.commission;
		  totals.remaining += state.remaining;
		});

		const map = {
		  "total-should": totals.should,
		  "total-withdrawn": totals.withdrawn,
		  "total-commission": totals.commission,
		  "total-remaining": totals.remaining,
		};
		Object.entries(map).forEach(([id, val]) => {
		  const target = document.getElementById(id);
		  if (target) {
			target.textContent = formatNumber(val);
		  }
		});
	  }

	  function applyFullState(row, confirmChange = false) {
		const fullEl = row.querySelector(".full");
		const withdrawnEl = row.querySelector(".withdrawn");
		const commissionEl = row.querySelector(".commission");
		const full = fullEl?.checked ?? false;
		if (full && confirmChange && withdrawnEl && withdrawnEl.value.trim()) {
		  const ok = window.confirm("Full will ignore the Taken amount. Continue?");
		  if (!ok) {
			return false;
		  }
		}
		if (withdrawnEl) {
		  withdrawnEl.disabled = full;
		}
		if (commissionEl) {
		  commissionEl.disabled = full;
		}
		return true;
	  }

	  async function autosave(row) {
		const cardId = row.dataset.cardId;
		const workdate = document.getElementById("workdate").value;
		const now = new Date();
		const hh = String(now.getHours()).padStart(2, "0");
		const mm = String(now.getMinutes()).padStart(2, "0");
		const timestamp = workdate && hh && mm ? `${workdate} ${hh}:${mm}` : "";
		const tzOffset = now.getTimezoneOffset();

		const fullEl = row.querySelector(".full");
		const withdrawnEl = row.querySelector(".withdrawn");
		const commissionEl = row.querySelector(".commission");
		const noteEl = row.querySelector(".note");

		const full = fullEl?.checked ?? false;
		if (withdrawnEl) {
		  withdrawnEl.disabled = full; // keeps UI aligned with server logic
		}

		const formData = new FormData();
		formData.append("date", workdate);
		formData.append("timestamp", timestamp);
		formData.append("tz_offset", tzOffset);
		formData.append("card_id", cardId);
		formData.append("fully_withdrawn", full ? "true" : "false");
		formData.append("withdrawn_rub", full ? "" : normalizeNumberString(withdrawnEl?.value ?? ""));
		formData.append("commission_rub", full ? "" : normalizeNumberString(commissionEl?.value ?? ""));
		formData.append("note", noteEl?.value ?? "");


		inFlight++;
		setSavingText();

		try {
		  // keepalive helps the request finish even if navigation starts
		  const resp = await fetch("/withdraw/save/", {
			method: "POST",
			headers: { "X-CSRFToken": csrftoken },
			body: formData,
			keepalive: true
		  });
		  if (!resp.ok) throw new Error("Save failed: " + resp.status);
		} catch (e) {
		  alert("Autosave failed. Please try again.\n\n" + e);
		} finally {
		  inFlight--;
		  setSavingText();

		  // If user changed date while saving, navigate after all saves finish
		  if (inFlight === 0 && pendingNavUrl) {
			const url = pendingNavUrl;
			pendingNavUrl = null;
			window.location.href = url;
		  }
		}
	  }

	  function formatNumericInputs() {
		document.querySelectorAll(".withdrawn, .commission").forEach(input => {
		  const raw = input.value;
		  if (!raw) return;
		  input.value = formatNumber(parseNumber(raw));
		});
	  }

	  function bindRows() {
		document.querySelectorAll("tr[data-card-id]").forEach(row => {
		  if (row.dataset.bound) return;
		  row.dataset.bound = "1";
		  row.addEventListener("change", (e) => {
			if (e.target.classList.contains("full")) return;
			refreshTotals();
			autosave(row);
		  });

		  const fullEl = row.querySelector(".full");
		  if (fullEl) {
			fullEl.addEventListener("change", () => {
			  const applied = applyFullState(row, true);
			  if (!applied) {
				fullEl.checked = false;
				applyFullState(row, false);
				return;
			  }
			  refreshTotals();
			  autosave(row);
			});
			applyFullState(row, false);
		  }

		  row.addEventListener("input", (e) => {
			if (e.target.classList.contains("withdrawn") || e.target.classList.contains("commission")) {
			  refreshTotals();
			}
		  });

		  row.querySelectorAll(".withdrawn, .commission").forEach(input => {
			input.addEventListener("blur", () => {
			  if (!input.value) return;
			  input.value = formatNumber(parseNumber(input.value));
			});
		  });
		});
	  }

	  const noteModal = document.getElementById("note-modal");
	  const noteTextarea = document.getElementById("note-modal-text");
	  const noteSaveBtn = noteModal?.querySelector("[data-note-action='save']");
	  const noteDeleteBtn = noteModal?.querySelector("[data-note-action='delete']");
	  const noteCancelBtn = noteModal?.querySelector("[data-note-action='cancel']");
	  let activeNoteRow = null;

	  function closeNoteModal() {
		noteModal?.classList.remove("is-open");
		activeNoteRow = null;
	  }

	  function openNoteModal(row) {
		if (!noteModal || !noteTextarea) return;
		activeNoteRow = row;
		const hidden = row.querySelector(".note");
		noteTextarea.value = hidden?.value || "";
		noteModal.classList.add("is-open");
		noteTextarea.focus();
	  }

	  function updateNoteDisplay(row, value) {
		const hidden = row.querySelector(".note");
		if (hidden) {
		  hidden.value = value;
		}
		const cell = row.querySelector(".note-cell");
		if (!cell) return;
		const trigger = cell.querySelector(".note-trigger");
		if (trigger) {
		  trigger.innerHTML = value
			? `<span class="note-icon" title="${escapeHtml(value)}">i</span>`
			: `<span class="note-icon">+</span>`;
		  trigger.setAttribute("aria-label", value ? "Edit note" : "Add note");
		}
		cell.classList.toggle("has-note", Boolean(value));
	  }

	  function bindNotes() {
		document.querySelectorAll(".note-trigger").forEach(btn => {
		  if (btn.dataset.bound) return;
		  btn.dataset.bound = "1";
		  const row = btn.closest("tr[data-card-id]");
		  if (!row) return;
		  const hidden = row.querySelector(".note");
		  updateNoteDisplay(row, hidden?.value || "");
		  btn.addEventListener("click", () => openNoteModal(row));
		});
	  }

	  noteSaveBtn?.addEventListener("click", () => {
		if (!activeNoteRow || !noteTextarea) return;
		const value = noteTextarea.value.trim();
		updateNoteDisplay(activeNoteRow, value);
		closeNoteModal();
		autosave(activeNoteRow);
	  });

	  noteDeleteBtn?.addEventListener("click", () => {
		if (!activeNoteRow) return;
		updateNoteDisplay(activeNoteRow, "");
		closeNoteModal();
		autosave(activeNoteRow);
	  });

	  noteCancelBtn?.addEventListener("click", () => closeNoteModal());
	  noteModal?.addEventListener("click", (e) => {
		if (e.target === noteModal) {
		  closeNoteModal();
		}
	  });
	  document.addEventListener("keydown", (e) => {
		if (e.key === "Escape" && noteModal?.classList.contains("is-open")) {
		  closeNoteModal();
		}
	  });

	  bindRows();
	  bindNotes();
	  formatNumericInputs();
	  refreshTotals();

	  // --- Date/bank filters + live search ---
	  const wd = document.getElementById("workdate");
	  const bankHidden = document.getElementById("bank-filter");
	  const bankInput = document.getElementById("bank-input");
	  const bankDropdown = bankInput?.parentElement?.querySelector(".combo-dropdown");
	  const searchInput = document.getElementById("withdraw-search");
	  const perPageSelect = document.getElementById("withdraw-per-page");
	  const perPageLabel = document.querySelector(".withdraw-per-page");
	  const tbody = document.querySelector(".table-card table tbody");
	  const pagination = document.querySelector(".pagination");
	  const initialBody = tbody ? tbody.innerHTML : "";
	  const initialPagination = pagination ? pagination.innerHTML : "";
	  const initialPaginationDisplay = pagination ? pagination.style.display : "";
	  let searchController = null;
	  let searchTimer;

	  const bankOptions = Array.from(document.querySelectorAll("#withdraw-bank-options option")).map(opt => ({
		id: opt.dataset.id || opt.value,
		label: opt.value
	  }));

	  function setUrlQuery(term) {
		const params = new URLSearchParams();
		const d = wd?.value || "";
		const bank = bankHidden?.value || "";
		const perPage = perPageSelect?.value || "";
		if (d) params.set("date", d);
		if (bank) params.set("bank", bank);
		if (term) params.set("q", term);
		if (perPage) params.set("per_page", perPage);
		const query = params.toString();
		const url = query ? `/withdraw/?${query}` : "/withdraw/";
		window.history.replaceState({}, "", url);
	  }

	  function buildSearchParams(term) {
		const params = new URLSearchParams();
		const d = wd?.value || "";
		const bank = bankHidden?.value || "";
		if (d) params.set("date", d);
		if (bank) params.set("bank", bank);
		if (term) params.set("q", term);
		return params;
	  }

	  function togglePagination(show) {
		if (!pagination) return;
		pagination.style.display = show ? initialPaginationDisplay || "" : "none";
	  }

	  function togglePerPage(show) {
		if (!perPageLabel) return;
		perPageLabel.style.display = show ? "" : "none";
	  }

	  function renderRows(items) {
		if (!tbody) return;
		if (!items.length) {
		  tbody.innerHTML = "<tr><td colspan=\"8\">No cards to withdraw for this date.</td></tr>";
		  return;
		}
		tbody.innerHTML = items.map(item => {
		  const cardLabel = escapeHtml(item.card_label);
		  const pin = escapeHtml(item.pin);
		  const shouldRaw = item.should_have || "0";
		  const remainingRaw = item.remaining || "0";
		  const should = formatNumber(parseNumber(shouldRaw));
		  const remaining = formatNumber(parseNumber(remainingRaw));
		  const fullAttr = item.fully_withdrawn ? "checked" : "";
		  const disabledAttr = item.fully_withdrawn ? "disabled" : "";
		  const withdrawnVal = item.withdrawn_rub ? formatNumber(parseNumber(item.withdrawn_rub)) : "";
		  const commissionVal = item.commission_rub ? formatNumber(parseNumber(item.commission_rub)) : "";
		  const note = item.note || "";
		  const noteClass = note ? "note-cell has-note" : "note-cell";
		  const noteIcon = note
			? `<span class="note-icon" title="${escapeHtml(note)}">i</span>`
			: `<span class="note-icon">+</span>`;
		  const noteLabel = note ? "Edit note" : "Add note";
		  return `
			<tr data-card-id="${escapeHtml(item.card_id)}" data-should="${escapeHtml(shouldRaw)}">
			  <td class="col-card">${cardLabel}</td>
			  <td><b>${pin}</b></td>
			  <td class="num col-money"><b>${should} ₽</b></td>
			  <td class="col-full">
				<input type="checkbox" class="full" ${fullAttr}>
			  </td>
			  <td class="num col-money-input">
				<input type="text" inputmode="decimal" class="withdrawn" value="${escapeHtml(withdrawnVal)}" ${disabledAttr}>
			  </td>
			  <td class="num col-money-input">
				<input type="text" inputmode="decimal" class="commission" value="${escapeHtml(commissionVal)}" ${disabledAttr}>
			  </td>
			  <td class="num col-money"><b class="remaining-value">${remaining} ₽</b></td>
			  <td>
				<div class="${noteClass}">
				  <button type="button" class="note-trigger" aria-label="${noteLabel}">${noteIcon}</button>
				  <input type="hidden" class="note note-input" value="${escapeHtml(note)}">
				</div>
			  </td>
			</tr>
		  `;
		}).join("");
	  }

	  function restoreInitial() {
		if (tbody) tbody.innerHTML = initialBody;
		if (pagination) pagination.innerHTML = initialPagination;
		togglePagination(true);
		togglePerPage(true);
		bindRows();
		bindNotes();
		refreshTotals();
	  }

	  function applySearch() {
		if (!searchInput) return;
		const term = searchInput.value.trim();
		setUrlQuery(term);
		if (!term) {
		  restoreInitial();
		  return;
		}
		togglePagination(false);
		togglePerPage(false);
		if (searchController) searchController.abort();
		searchController = new AbortController();
		const params = buildSearchParams(term);
		fetch(`/withdraw/search/?${params.toString()}`, { signal: searchController.signal })
		  .then(resp => resp.ok ? resp.json() : { results: [] })
		  .then(data => {
			renderRows(data.results || []);
			bindRows();
			bindNotes();
			refreshTotals();
		  })
		  .catch(() => {});
	  }

	  function navigateWithFilters() {
		if (searchInput && searchInput.value.trim()) {
		  applySearch();
		  return;
		}
		const params = new URLSearchParams();
		const d = wd?.value || "";
		const bank = bankHidden?.value || "";
		const perPage = perPageSelect?.value || "";
		if (d) params.set("date", d);
		if (bank) params.set("bank", bank);
		if (perPage) params.set("per_page", perPage);
		const url = `/withdraw/?${params.toString()}`;

		if (inFlight > 0) {
		  pendingNavUrl = url; // wait until saves finish
		} else {
		  window.location.href = url;
		}
	  }

	  if (wd) {
		wd.addEventListener("change", navigateWithFilters);
	  }
	  if (perPageSelect) {
		perPageSelect.addEventListener("change", navigateWithFilters);
	  }
	  if (searchInput) {
		searchInput.addEventListener("keydown", (e) => {
		  if (e.key === "Enter") {
			e.preventDefault();
		  }
		});
		searchInput.addEventListener("input", () => {
		  window.clearTimeout(searchTimer);
		  searchTimer = window.setTimeout(applySearch, 200);
		});
	  }
	  if (bankHidden && bankInput && bankDropdown) {
		const filterOptions = term => {
		  const q = term.trim().toLowerCase();
		  const matches = q
			? bankOptions.filter(opt => opt.label.toLowerCase().includes(q)).slice(0, 8)
			: bankOptions;
		  return matches;
		};

		const findMatch = term => {
		  const lowered = term.trim().toLowerCase();
		  return bankOptions.find(opt => opt.label.toLowerCase() === lowered);
		};

		const findFirstMatch = term => {
		  if (!term.trim()) return null;
		  const matches = filterOptions(term);
		  return matches.length ? matches[0] : null;
		};

		const applySelection = opt => {
		  if (!opt) return;
		  bankHidden.value = opt.id || "";
		  bankInput.value = opt.label;
		  bankDropdown.style.display = "none";
		  navigateWithFilters();
		};

		const updateDropdown = term => {
		  const matches = filterOptions(term);
		  bankDropdown.innerHTML = "";
		  if (!matches.length) {
			bankDropdown.style.display = "none";
			return;
		  }
		  bankDropdown.scrollTop = 0;
		  matches.forEach(opt => {
			const btn = document.createElement("button");
			btn.type = "button";
			btn.textContent = opt.label;
			btn.dataset.id = opt.id;
			bankDropdown.appendChild(btn);
		  });
		  bankDropdown.style.display = "block";
		  bankDropdown.querySelectorAll("button").forEach(btn => {
			btn.addEventListener("click", () => {
			  applySelection({ id: btn.dataset.id || "", label: btn.textContent });
			});
		  });
		};

		bankInput.addEventListener("focus", () => {
		  updateDropdown(bankInput.value);
		});

		bankInput.addEventListener("input", () => {
		  bankHidden.value = "";
		  if (bankInput.value.trim() === "") {
			bankDropdown.style.display = "none";
			navigateWithFilters();
		  } else {
			updateDropdown(bankInput.value);
		  }
		});

		document.addEventListener("click", (e) => {
		  if (!bankInput.parentElement.contains(e.target)) {
			bankDropdown.style.display = "none";
		  }
		});

		bankInput.addEventListener("keydown", (e) => {
		  if (e.key === "Enter") {
			e.preventDefault();
			const match = findMatch(bankInput.value) || findFirstMatch(bankInput.value);
			if (match) applySelection(match);
		  }
		  if (e.key === "Escape") {
			bankDropdown.style.display = "none";
		  }
		});

		bankInput.addEventListener("blur", () => {
		  setTimeout(() => {
			const active = document.activeElement;
			if (active && bankDropdown.contains(active)) {
			  return;
			}
			const match = findMatch(bankInput.value) || findFirstMatch(bankInput.value);
			if (match) {
			  applySelection(match);
			} else if (bankInput.value.trim() === "") {
			  bankHidden.value = "";
			  navigateWithFilters();
			} else {
			  bankInput.value = bankHidden.value;
			}
			bankDropdown.style.display = "none";
		  }, 120);
		});
	  }

	</script>



{% endblock %}
